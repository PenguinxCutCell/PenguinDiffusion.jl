var documenterSearchIndex = {"docs":
[{"location":"references/#API-Reference","page":"References","title":"API Reference","text":"","category":"section"},{"location":"references/#Index","page":"References","title":"Index","text":"Pages = [\"references.md\"]","category":"section"},{"location":"references/#Full-API","page":"References","title":"Full API","text":"","category":"section"},{"location":"references/#PenguinDiffusion.diphasic_unsteady_block_matrix-Union{Tuple{T}, Tuple{N}, Tuple{TwoPhaseDiffusionSystem{N, T}, Real}} where {N, T}","page":"References","title":"PenguinDiffusion.diphasic_unsteady_block_matrix","text":"diphasic_unsteady_block_matrix(sys, dt; scheme=:BE)\n\nAssemble two-phase unsteady block matrix with unknown ordering: x = [uω1; uγ1; uω2; uγ2].\n\n\n\n\n\n","category":"method"},{"location":"references/#PenguinDiffusion.diphasic_unsteady_block_solve-Union{Tuple{T}, Tuple{N}, Tuple{TwoPhaseDiffusionSystem{N, T}, AbstractVector, Tuple{Real, Real}}} where {N, T}","page":"References","title":"PenguinDiffusion.diphasic_unsteady_block_solve","text":"diphasic_unsteady_block_solve(sys, u0, tspan; dt, scheme=:CN, ...)\n\nFixed-step two-phase assembled block loop with ordering x = [uω1; uγ1; uω2; uγ2].\n\n\n\n\n\n","category":"method"},{"location":"references/#PenguinDiffusion.unsteady_block_matrix-Union{Tuple{T}, Tuple{N}, Tuple{DiffusionSystem{N, T}, Real}} where {N, T}","page":"References","title":"PenguinDiffusion.unsteady_block_matrix","text":"unsteady_block_matrix(sys, dt; scheme=:BE)\n\nAssemble the monophase unsteady block matrix on reduced DOFs using unknown ordering x = [u_omega; u_gamma].\n\nFor scheme=:BE:\n\nA11 = M - dt*L_oo\nA12 = -dt*L_og\nA21 = C_omega\nA22 = C_gamma\n\nFor scheme=:CN:\n\nA11 = M - dt/2*L_oo\nA12 = -dt/2*L_og\nA21 = C_omega\nA22 = C_gamma\n\n\n\n\n\n","category":"method"},{"location":"references/#PenguinDiffusion.unsteady_block_solve-Union{Tuple{T}, Tuple{N}, Tuple{DiffusionSystem{N, T}, AbstractVector, Tuple{Real, Real}}} where {N, T}","page":"References","title":"PenguinDiffusion.unsteady_block_solve","text":"unsteady_block_solve(sys, u0_omega, tspan; dt, scheme=:CN, ...)\n\nFixed-step implicit time loop using the assembled block matrix with unknown ordering x = [u_omega; u_gamma], reproducing the legacy assembled strategy.\n\nscheme=:BE is first-order in time; scheme=:CN is second-order and typically gives much lower temporal error at the same dt.\n\nReturns a named tuple with fields:\n\nt: saved time points\nomega: saved u_omega states\ngamma: saved u_gamma states\nstates: saved block states [u_omega; u_gamma]\nscheme, dt\n\n\n\n\n\n","category":"method"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page lists the package public API.","category":"section"},{"location":"api/#Problem-and-System-Types","page":"API Reference","title":"Problem and System Types","text":"DiffusionProblem\nDiffusionSystem\nTwoPhaseDiffusionProblem\nTwoPhaseDiffusionSystem","category":"section"},{"location":"api/#Build-and-State","page":"API Reference","title":"Build and State","text":"build_system\nbuild_matrixfree_system\nenable_matrixfree_unsteady!\nfull_state","category":"section"},{"location":"api/#Monophasic-Updaters","page":"API Reference","title":"Monophasic Updaters","text":"RobinGUpdater\nRobinABUpdater\nBoxDirichletUpdater\nKappaUpdater\nSourceUpdater","category":"section"},{"location":"api/#Two-Phase-Updaters","page":"API Reference","title":"Two-Phase Updaters","text":"FluxJumpGUpdater\nFluxJumpBUpdater\nScalarJumpGUpdater\nScalarJumpAlphaUpdater\nKappa1Updater\nKappa2Updater\nBoxDirichletUpdater1\nBoxDirichletUpdater2\nSource1Updater\nSource2Updater","category":"section"},{"location":"api/#Steady-Solve-Helpers","page":"API Reference","title":"Steady Solve Helpers","text":"steady_linear_problem\nsteady_solve","category":"section"},{"location":"api/#Assembled-Block-Unsteady-Helpers","page":"API Reference","title":"Assembled Block Unsteady Helpers","text":"unsteady_block_matrix\nunsteady_block_solve\ndiphasic_unsteady_block_matrix\ndiphasic_unsteady_block_solve","category":"section"},{"location":"equations/#Equations","page":"Equations","title":"Equations","text":"PenguinDiffusion.jl solves diffusion operators on cut-cell geometries.","category":"section"},{"location":"equations/#Monophasic-Form","page":"Equations","title":"Monophasic Form","text":"For active phase omega, the semidiscrete system is assembled as:\n\nM dot u = L_omega(u kappa textBC textinterface) + V odot f\n\nwith steady form:\n\n0 = L_omega(u kappa textBC textinterface) + V odot f\n\nwhere M is the reduced diagonal mass matrix from active-cell volumes.","category":"section"},{"location":"equations/#Two-Phase-Form","page":"Equations","title":"Two-Phase Form","text":"For phases omega_1 and omega_2, the package builds a coupled reduced system with:\n\nper-phase diffusion coefficients (kappa1, kappa2),\nper-phase box BCs,\ninterface scalar-jump and flux-jump constraints.","category":"section"},{"location":"equations/#Interface-Constraints","page":"Equations","title":"Interface Constraints","text":"The interface is represented through CartesianOperators constraints:\n\nRobinConstraint for monophasic interface closure,\nFluxJumpConstraint and ScalarJumpConstraint for two-phase coupling.","category":"section"},{"location":"design/#Design-Notes","page":"Design Notes","title":"Design Notes","text":"","category":"section"},{"location":"design/#Architecture","page":"Design Notes","title":"Architecture","text":"PenguinDiffusion.jl is built around reduced active-cell state vectors and explicit reconstruction to full-grid caches for operator calls.","category":"section"},{"location":"design/#Core-Contracts","page":"Design Notes","title":"Core Contracts","text":"PenguinSolverCore.rhs!(du, sys, u, p, t) for unsteady integration.\nPenguinSolverCore.mass_matrix(sys) for semidiscrete mass scaling.\nPenguinSolverCore.rebuild!(sys, u, p, t) for scheduled updater application.","category":"section"},{"location":"design/#Two-Phase-Layout","page":"Design Notes","title":"Two-Phase Layout","text":"Two-phase systems keep separate reduced DOF maps per phase and couple them through interface constraints assembled by CartesianOperators.","category":"section"},{"location":"design/#Matrix-Free-Path","page":"Design Notes","title":"Matrix-Free Path","text":"For large unsteady runs, matrix-free system construction avoids explicit sparse matrix assembly and applies operators through preallocated work buffers.","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"Run examples from repository root:\n\njulia --project examples/<file>.jl\n\nAvailable scripts include:\n\nrobin_disk_steady.jl\nrobin_disk_unsteady.jl\nrobin_disk_unsteady_matrixfree.jl\nfull_domain_manufactured_steady.jl\nfull_domain_manufactured_unsteady.jl\noutside_circle_manufactured_steady.jl\none_d_continuous_body_halfspace_boxbc.jl\ntwophase_square_circle_continuity_steady.jl\ntwophase_square_circle_continuity_unsteady.jl\nheat_2ph_2d_benchphaseflow.jl\n\nNotes:\n\nrobin_disk_unsteady_blockloop.jl demonstrates the monophasic assembled block loop.\nheat_2ph_2d_benchphaseflow.jl demonstrates the diphasic assembled block loop and full-vector volume-weighted error norms.","category":"section"},{"location":"validation/#Validation","page":"Validation","title":"Validation","text":"Suggested validation checks for this package:\n\nManufactured-solution convergence in steady full-domain and cut-domain settings.\nRobin interface consistency checks against analytical radial solutions.\nTwo-phase interface continuity checks (scalar jump and flux jump).\nUnsteady regression checks against known final-time fields.\nAllocation regressions for repeated RHS calls.\nAssembled block-loop checks:\none-step equivalence vs direct block linear solve,\nshort-final-step handling,\nscheduled updater firing at exact times.\nFull-vector volume-weighted error norms (not active-index-only norms), so outside regions contribute zero naturally via V=0.\n\nThe scripts in examples/ can be adapted into reproducible convergence and regression tests.","category":"section"},{"location":"boundary-conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"boundary-conditions/#Box-Boundary-Conditions","page":"Boundary Conditions","title":"Box Boundary Conditions","text":"Outer-box boundaries are passed through CartesianOperators.BoxBC.\n\nCommon choices include:\n\nDirichlet(value)\nNeumann(value)\nPeriodic(...) where supported by the underlying operator\n\nIf omitted, default box conditions come from BoxBC(Val(N), T).","category":"section"},{"location":"boundary-conditions/#Embedded-Interface-Conditions","page":"Boundary Conditions","title":"Embedded Interface Conditions","text":"Monophasic problems use:\n\nRobinConstraint(a, b, g)\n\nTwo-phase problems use:\n\nFluxJumpConstraint(b1, b2, g_flux)\nScalarJumpConstraint(alpha1, alpha2, g_scalar)\n\nAll three fields can be scalar, full-grid vectors, or runtime-updated via updaters.","category":"section"},{"location":"#PenguinDiffusion.jl","page":"Home","title":"PenguinDiffusion.jl","text":"PenguinDiffusion.jl provides cut-cell diffusion solvers on reduced active-cell states.\n\nCurrent capabilities include:\n\nMonophasic diffusion systems with embedded Robin interface constraints.\nTwo-phase diffusion systems with scalar-jump and flux-jump constraints.\nSteady solves via LinearSolve.\nUnsteady solves via PenguinSolverCore + SciML ODE integration.\nMatrix-free unsteady RHS path for large problems.\nAssembled block unsteady solvers for monophasic and diphasic systems.","category":"section"},{"location":"#Documentation-Map","page":"Home","title":"Documentation Map","text":"Equations: governing forms solved by this package.\nBoundary Conditions: box BCs and interface constraints.\nNumerics: reduced-state masking, operators, and runtime updates.\nAPI Reference: exported constructors/functions.\nExamples: runnable scripts under examples/.\nValidation: recommended verification checks.\nDesign Notes: implementation-level architecture notes.","category":"section"},{"location":"numerics/#Numerics","page":"Numerics","title":"Numerics","text":"","category":"section"},{"location":"numerics/#Reduced-State","page":"Numerics","title":"Reduced State","text":"Unknowns are stored only on active cells using PenguinSolverCore.DofMap.\n\nThe package maintains internal full-grid caches for:\n\nreconstruction of full fields,\noperator application,\ninterface coupling terms.","category":"section"},{"location":"numerics/#Build-Paths","page":"Numerics","title":"Build Paths","text":"build_system(...) assembles the standard diffusion system.\nbuild_matrixfree_system(...) builds the matrix-free unsteady path.\nunsteady_block_* and diphasic_unsteady_block_* provide assembled block fixed-step implicit time loops.","category":"section"},{"location":"numerics/#Two-Phase-Flux/Scalar-Jump-Conventions","page":"Numerics","title":"Two-Phase Flux/Scalar Jump Conventions","text":"For diphasic coupling:\n\nScalar jump rows enforce α1*T1 + α2*T2 = g_scalar at the interface.\nFlux jump rows enforce b1*q1 + b2*q2 = g_flux with opposite phase normals.\n\nThis means physical flux continuity D1*∂nT1 = D2*∂nT2 maps to:\n\nFluxJumpConstraint(b1=D1, b2=-D2, g=0).","category":"section"},{"location":"numerics/#Runtime-Updates","page":"Numerics","title":"Runtime Updates","text":"The package exposes updater types for time-dependent coefficients/BCs/source terms, including:\n\nRobinGUpdater, RobinABUpdater\nBoxDirichletUpdater, KappaUpdater, SourceUpdater\ntwo-phase updater variants (...1Updater, ...2Updater, jump updaters)\n\nThese updaters integrate with PenguinSolverCore.rebuild! scheduling.","category":"section"}]
}
